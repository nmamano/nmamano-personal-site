<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Nil Mamano | Blog</title>
    <meta name="person" content="Nil Mamano" />
    <meta name="sortname" content="Mamano, Nil" />
    <meta name="keywords" content="personal site,computer science,blog" />
    <meta
      name="description"
      content="Negative Binary Search and Choir Rehearsal"
    />

    <meta property="og:title" content="Nil Mamano | Blog" />
    <meta
      property="og:description"
      content="Negative Binary Search and Choir Rehearsal"
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:url"
      content="http://nilmamano.com/blog/negativebinarysearch/negativebinarysearch.html"
    />
    <meta
      property="og:image"
      content="http://nilmamano.com/blog/negativebinarysearch/THUMBNAIL **********************"
    />

    <link
      href="https://fonts.googleapis.com/css?family=Roboto"
      rel="stylesheet"
    />
    <link href="../../css/style.css" rel="stylesheet" />
    <link rel="stylesheet" href="../css/default.min.css" />
  </head>

  <body class="blogpostpage">
    <main class="blogpost">
      <div class="blogreturn">
        <p>Return to the <a href="../../blog.html">blog's main page</a>.</p>
      </div>

      <div id="mdToHtml">
        <h1 id="negative-binary-search-and-choir-practice">
          Negative Binary Search and Choir Rehearsal
        </h1>
        <p>
          One of the points we touch on on the upcoming book (Beyond Cracking
          the Coding Interview) is that binary search has many interesting
          applications beyond finding an element in a sorted array. I'll share
          an example based on a personal story that's a bit too niche for the
          book but kind of fun.
        </p>
        <p>
          A friend sings in a choir of 40-50 people, and they told me that, in
          the last rehearsal, the conductor could hear one person singing the
          wrong part but couldn't identify who. The conductor tried to isolate
          where the wrong part was coming from by basically
          <strong>binary searching</strong> the choir members, but there was an
          issue: when the conductor narrowed down the source to a small enough
          group, the issue disappeared. Whoever was singing the wrong part was
          only getting tripped up by hearing other people singing around them,
          but would sign their part perfectly in isolation. Eventually, the
          conductor gave up.
        </p>
        <p>
          What should the conductor have done? More precisely, what algorithm
          should they have used to find the culprit? First, let's formalize the
          problem.
        </p>
        <h2 id="the-problem">The problem</h2>
        <p>
          You are given <code>n</code>, the number of singers, and a number
          <code>k &lt; n/2</code>. You have <code>n</code> singers, say, singer
          <code>1</code> to singer <code>n</code>, and you can make any subset
          sing a song. This gives you 1 bit of information: whether they all
          sang it correctly or whether someone in that group messed up. All the
          singers always sing the right part except one, who sings the wrong
          part, but <strong>only</strong> if at least <code>k</code> people are
          singing with them. How do you find who it is?
        </p>
        <h2 id="the-solution">The solution</h2>
        <p>
          The key is to do a kind of "negative binary search," where you make
          everyone sing <strong>except the subset you want to test.</strong> You
          know the culprit is in a subset when everyone else sings correctly.
        </p>
        <p>
          Example: imagine <code>n</code> is <code>100</code> and
          <code>k</code> is <code>30</code>.
        </p>
        <p>Iteration 1:</p>
        <ul>
          <li>The culprit is in range 1-100.</li>
          <li>You split the range into 1-50 and 51-100.</li>
          <li>
            You want to check if the culprit is in 1-50, so you make everyone
            else (51-100) sing.
          </li>
          <li>
            Imagine they sing <strong>correctly</strong>. That means the culprit
            is in 1-50.
          </li>
        </ul>
        <p>Iteration 2:</p>
        <ul>
          <li>The culprit is in range 1-50.</li>
          <li>You split the range into 1-25 and 26-50.</li>
          <li>
            You want to check if the culprit is in 1-25, so you make everyone
            else (26-100) sing.
          </li>
          <li>
            Imagine they sing <strong>incorrectly.</strong> That means the
            culprit is in 26-50.
          </li>
        </ul>
        <p>Iteration 3:</p>
        <ul>
          <li>The culprit is in range 26-50.</li>
          <li>You split the range into 26-38 and 39-50.</li>
          <li>
            You want to check if the culprit is in 26-38, so you make everyone
            else (1-25 and 39-100) sing.
          </li>
          <li>
            Imagine they sing <strong>correctly.</strong> That means the culprit
            is in 26-38.
          </li>
        </ul>
        <p>
          And so on. In this way, the conductor could have found the culprit in
          <code>O(log n)</code> steps.
        </p>
        <p>Credit to Timothy Johnson for the "negative binary search" idea.</p>
      </div>

      <div class="blogreturn">
        <p>Return to the <a href="../../blog.html">blog's main page</a>.</p>
      </div>
    </main>
  </body>
</html>
